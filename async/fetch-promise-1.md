# Promise
Promise позволяют избавиться от множества колбэков.

Заменим код с `XMLHttpRequest`:

    const request = new XMLHttpRequest() // Создаём AJAX запрос
    request.open('GET', 'data.json')     // Открываем AJAX-запрос
    request.send() // Отправляем запрос

    request.addEventListener('load', function() {
        const data = JSON.parse(this.responseText) // Преобразовываем JSON-данные в JavaScript-объект
    }

На более современный вызов AJAX `Promise` с `Fetch API` (функция fetch() создаёт промис и возвращает его для употребления):

    // Создание AJAX-запроса, открытие (GET), отправка, возвращает Promise
    const request = fetch(`data.json`)

    console.log(request) // Promise {...}

Если всё нормально, консоль должен показать примерный код:

    Promise { <state>: "pending" }
        <state>: "fulfilled"​
        <value>:
            body: ReadableStream { locked: false }​​
            bodyUsed: false​​
            headers: Headers {  }​​
            ok: true​​
            redirected: false​​
            status: 200​​
            statusText: "OK"​​
            type: "basic"​​
            url: "http://localhost:5500/async/example/data.json"

В переменной request хранится объект `Promise`.

## Что такое Promise
Promise (обещание) - это объект который используется в качестве заполнителя для будущего результата асинхронной операции.  
Promise - это контейнер для асинхронно доставленно значения.
Promise - это контейнер для будущего значения. (Например ответ от вызова AJAX).

Благодаря промисам, события (load) и вложенные колбэки больше не нужны для обработки асинхронных результатов. Вместо вложенного колбэк, используют цепочку промисов.

Промисы работают с асинхронными операциями и поэтому меняются со временем, могут иметь несколько состояний.

## Жизненный цикл Promise (состояния)
- pending (начальное состояние) - ожидание, до того как станет доступно будущее значение
    - во время pending, асинхронная задача выполняется в фоновом режиме
- состояние решено (два разных типа решенных состояний)
    - выполнено (fulfilled), например данный из data.json получены
    - отклонено (rejected)

Различные состояния промиса можно обрабатывать в коде.  
Состояния промисов полезны, когда мы используем промис для получения результа, этот процесс называется `потребление промиса`.  
Потребление промиса происходит тогда, когда у нас уже есть промис (например возвращённый из функции Fetch).  
Функция fetch() создаёт промис и возвращает его для употребления, поэтому нам не нужно самим создавать промисы.
