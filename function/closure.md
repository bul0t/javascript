# Замыкание
Замыкание - это функция вместе со всеми внешними переменными, которые ей доступны.  
JavaScript разрешает выполнять функции по ходу выполнения скипта и эти функции имеют доступ к переменным внешней функции.  

## Lexical environment (лексическое окружение)
Все переменные внутри функции, это свойства специального внутреннего объекта `lexical environment`, который создаётся при её запуске.  
Данный объект является внутренним и он скрыт от прямого доступа.  
При вызове, функция создаёт объект `lexical environment` и записывает туда аргументы, функции и переменные.  
Процесс инициализации выполняется в том же порядке, что и для глобального объекта (глабольной области видимости?), который является частным случаем лексического окружения.

## Жизненный цикл функции
Рассмотрим пример показывающий жизненный цикл, функции:

    function sayHi(name) {
      var phrase = 'Hello, ' + name
      console.log(phrase)
    }

    sayHi('Jack')

До выполнения первой строчки функции `var phrase ...`, на стадии инициализации функции, интерпретатор создаёт пустой объект `lexical environment` и заполняет его.  
В нашем примере в этот объект попадает параметр `name` и переменная `pharse`:

    LexicalEnvironment { name = 'Jack', pharse = undefined }

Далее начинает выполняться функция, в это время локальной переменной pharse присваивается значение:

    LexicalEnvironment { name = 'Jack', pharse = 'Hello, Jack' }

Далее фраза выводится в консоль.  
В конце после выполнения функции объект `LexicalEnvironment` удаляется, а память очищается (сборщиком мусора).  
Из функции мы можем обратиться не только к локальным переменным но и к внешним.  

## Внешние переменные, scoupe

    var userName = 'Jack'

    function sayHi() {
      console.log(userName)
    }

    sayHi()

Интепретатор при доступе к переменной внутри функции, сначала пытается найти её в текущем `LexicalEnvironment`, а затем если её там нет ищет во внешнем лексическом окружении.  
Такой порядок поиска возможен благодаря тому что ссылка на внешний `LexicalEnvironment` хранится в специальном внутреннем свойстве функции, которая называется **scoupe**.

При создании, функция получает скрытое свойство `scoupe`, которая ссылается на лексическое окружение в котором она была вызвана.  
В браузере таким окружением является `Window`.  
При запуске функции, её объект переменных `LexicalEnvironment` получает ссылку на внешнее лексическое окружение.  
Функция внутри функции получает данные из переменных внешней функции.  

Замыкание - это когда объект локальных переменных `scope` внешней функции, остаётся жить после её завершения. Внурення функция может обратиться к нему в любой момент и получить переменную внешней функции.

    function sum(a) {
      return function(b) {
        return a + b
      }
    }

    console.log( sum(1)(2) ) // 3

## Счетчик
Создание счетчика, который считает вызовы функции и возвращает их текущее число.

function makeCounter() {
  var currentCount = 1
  return function() {
    return currentCount++
  }
}

var counter = makeCounter()
var counter2 = makeCounter()

console.log( counter() ) // 1
console.log( counter() ) // 2
console.log( counter() ) // 3

console.log( counter2() ) // 1
console.log( counter2() ) // 2
console.log( counter2() ) // 3

Мы получили два независимых счетчика counter и counter2, каждый из которых сохраняет во внешней переменной `currentCount` текущее количество вызовов.

## Пример с кнопками
По клику по кнопке, в консоли должен появлятся её порядковый номер.

index.html:

    <button></button>
    <button></button>
    <button></button>
    <button></button>
    <button></button>
    <button></button>
    <button></button>
    <button></button>
    <button></button>
    <button></button>

custom.js:

    var buttons = document.querySelectorAll('button')

    for(var i = 0; i < buttons.length; i++) {
      buttons[i].innerHTML = i
      buttons[i].onclick = function() {
        console.log(i)
      }
    }

Данный пример ожно решить через let или через замыкание.

var buttons = document.querySelectorAll('button')

    for(var i = 0; i < buttons.length; i++) {
      buttons[i].innerHTML = i
      buttons[i].onclick = function(x) {
        return function() {
          console.log(x)
        }
      }(i)
    }

Каждый раз при клике по кнопке, мы вызываем функцию внутри которой создан объект `LexicalEnvironment` в котором будет свойство x со значением i. Объект `LexicalEnvironment` создаётся заного при каждом вызове функции.

## Итого
- все переменные и параметры функций, являются свойствами объекта переменных `LexicalEnvironment`
- каждый запуск функции создаёт новый такой объект
- на верхнем уровне `LexicalEnvironment` является глобальный объект, например Window в браузере
- при создании, функция получает системное свойство `scoupe`, которое ссылается на `LexicalEnvironment` в котором оно было создано
- при вызове функции куда бы её не передали в коде, она будет искать переменные сначала у себя, а затем во внешних `LexicalEnvironment`, с того места где она создана
- Scope - лексическое окружение функции
- sum()() - создали функцию sum и вызывали её с параметром - синтаксис sum(a). Данная функция при выполнении возвращает вложенную функцию (у неё нет имени просто function(){}), которую мы тоже хотим выполнить, т.е. нам нужно выполнить сначала внешнюю функцию, а потом тут же внутреннию, отсюда и двойные скобки ()() - выполнить функцию и выполнить внутреннию функцию, которая возвращает данная функция.
