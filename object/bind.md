# bind()

    var wrapper = func.bind(context, arg1, arg2, ...)

- func - это произвольная функция
- context - контекст который привязывается к func
- arg1, arg2, ... - аргументы, они будут прибавлены к каждому вызову новой функции и встанут перед теми которые указаны при вызове
- результат вызова `func.bind(context)` аналогичен `bind(func, context)`
- wrapper - это обертка фиксирующая контекст и передающая вызовы в func

Функции в JavaScript никак не привязаны к своему контексту this и с одной стороны это хорошо, так как позволяет быть максимвльно гибким, одалживать методы и т.д. Но с другой сторны в некоторых случаях контекст может быть потерян, например вызываем метод объекта и вместо this получаем undefined.

Пример, в браузере есть встроенная функция SetTimeout(), которая принимает функцию и запускает её через определённое время:

    setTimeout(function() {
      console.log('hello')
    }, 1000)

Попробуем сделать то же самое с методом объекта:

    var user = {
      userName: 'jack',
      sayHi: function() {
        console.log(this.userName)
      }
    }

    setTimeout(user.sayHi, 1000) // undefined

Получаем undefined, это произошло потому что в примере выше setTimeout получил функцию user.sayHi но не её контекст, и строка `setTimeout(user.sayHi, 1000)` аналогична этому коду:

    var f = user.sayHi;
    setTimeout(f, 1000) // undefined

Контекст user потерян.  
Ситуация довольно типична, мы хотим передать метод объекта куда-то в другое место откуда он потом может быть вызван, как бы прикрепить к нему контекст и используют для этого, метод `bind()`.

Создадим функцию которая будет выводить в консоль значение this, а также сумму переданных ей аргументов.  
Далее создадим переменную `g` которой присвоим значение данной функции, контекст которой привязан к `Context`.  
И вызовем функцию обертку `g`.

    function f(a, b) {
      console.log(this)
      console.log(a + b)
    }
    f(1,2) // Window, 3

    var g = f.bind('Context')
    g(3,4) // String { "Context" }, 7

Переделаем функцию, чтобы она выводила имя в консоль:

    var user = {
      userName: 'jack',
      sayHi: function() {
        console.log(this.userName)
      }
    }

    setTimeout(user.sayHi.bind(user), 1000) // jack

Функция сама по себе не запоминает контекст выполнения и чтобы гарантировать правильный контекст для вызова методов объекта, нужно использовать функцию обертку и задать её используя bind().

Вызов bind() часто используют для привязки функции к контексту чтобы затем присвоить её в обычную переменную и вызвать уже без явного указания объекта.

Вызов bind() также позволяет фиксировать первые аргументы функции, каррировать её и таким образом из общей функции получить её частные варианты, чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз.

Еще один пример явного связывания this с объектом:

    var user = {
      data: [
        {name: 'Иван'},
        {name: 'Петр'},
        {name: 'Сидор'},
      ],
      showFirst: function(event) {
        console.log(this.data[0].name)
      }
    }

    document.getElementById('btn').addEventListener('click', user.showFirst) // Uncaught TypeError: this.data is undefined

По клику `click` произойдет ошибка, потому что значение `this` в функции `showFirst` будет не объект `user`, а объект кнопки у которого отсутствует свойство `data`.

Чтобы избавиться от ошибки, привяжем контекст метода `showFirst` с помощью метода `bind()` к объекту `user`.

    document.getElementById('btn').addEventListener('click', user.showFirst.bind(user)) // Иван
